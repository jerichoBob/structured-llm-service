import { z } from 'zod';
import { createInstructorClient } from './instructorClient.js';

// Mock the external dependencies for testing
jest.mock('@instructor-ai/instructor');
jest.mock('openai');

import Instructor from '@instructor-ai/instructor';
import OpenAI from 'openai';

const mockInstructor = jest.mocked(Instructor);
const mockOpenAI = jest.mocked(OpenAI);

describe('Basic Schema Conversion with instructor-js', () => {
  let mockInstructorInstance: any;
  let mockOpenAIInstance: any;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Set up mock instances
    mockOpenAIInstance = {} as OpenAI;
    mockInstructorInstance = {
      chat: {
        completions: {
          create: jest.fn(),
        },
      },
    };

    mockOpenAI.mockImplementation(() => mockOpenAIInstance);
    mockInstructor.mockReturnValue(mockInstructorInstance);
  });

  describe('Schema Integration Tests', () => {
    it('should create instructor client and accept Zod schemas', () => {
      // Test that we can create a client
      const client = createInstructorClient({
        provider: 'openai',
        apiKey: 'test-key',
      });

      expect(client).toBeDefined();
      expect(client.chat).toBeDefined();
      expect(client.chat.completions).toBeDefined();
      expect(client.chat.completions.create).toBeDefined();
    });

    it('should pass Zod schemas to instructor-js correctly', async () => {
      const UserSchema = z.object({
        name: z.string(),
        age: z.number(),
      });

      const expectedResult = { name: 'John Doe', age: 30 };
      mockInstructorInstance.chat.completions.create.mockResolvedValue(expectedResult);

      const client = createInstructorClient({
        provider: 'openai',
        apiKey: 'test-key',
      });

      // Call the method without strict typing to avoid TypeScript issues
      const createMethod = client.chat.completions.create as any;
      const result = await createMethod({
        messages: [{ role: 'user', content: 'Extract user info: John Doe is 30 years old' }],
        model: 'gpt-4-turbo',
        response_model: {
          schema: UserSchema,
          name: 'User',
        },
      });

      expect(result).toEqual(expectedResult);
      expect(mockInstructorInstance.chat.completions.create).toHaveBeenCalledWith({
        messages: [{ role: 'user', content: 'Extract user info: John Doe is 30 years old' }],
        model: 'gpt-4-turbo',
        response_model: {
          schema: UserSchema,
          name: 'User',
        },
      });
    });

    it('should handle complex schemas with nested objects', async () => {
      const AddressSchema = z.object({
        street: z.string(),
        city: z.string(),
        zipCode: z.string(),
      });

      const UserWithAddressSchema = z.object({
        name: z.string(),
        email: z.string().email(),
        address: AddressSchema,
      });

      const expectedResult = {
        name: 'John Doe',
        email: 'john@example.com',
        address: {
          street: '123 Main St',
          city: 'Anytown',
          zipCode: '12345',
        },
      };

      mockInstructorInstance.chat.completions.create.mockResolvedValue(expectedResult);

      const client = createInstructorClient({
        provider: 'openai',
        apiKey: 'test-key',
      });

      const createMethod = client.chat.completions.create as any;
      const result = await createMethod({
        messages: [{ role: 'user', content: 'User: John Doe, john@example.com, lives at 123 Main St, Anytown, 12345' }],
        model: 'gpt-4-turbo',
        response_model: {
          schema: UserWithAddressSchema,
          name: 'UserWithAddress',
        },
      });

      expect(result).toEqual(expectedResult);
      
      // Verify the schema was passed correctly
      const callArgs = mockInstructorInstance.chat.completions.create.mock.calls[0][0];
      expect(callArgs.response_model.schema).toBe(UserWithAddressSchema);
    });

    it('should handle arrays and enums', async () => {
      const TaskSchema = z.object({
        title: z.string(),
        status: z.enum(['pending', 'in-progress', 'completed']),
        tags: z.array(z.string()),
        priority: z.number().min(1).max(5),
      });

      const expectedResult = {
        title: 'Complete project',
        status: 'in-progress',
        tags: ['urgent', 'development'],
        priority: 4,
      };

      mockInstructorInstance.chat.completions.create.mockResolvedValue(expectedResult);

      const client = createInstructorClient({
        provider: 'openai',
        apiKey: 'test-key',
      });

      const createMethod = client.chat.completions.create as any;
      const result = await createMethod({
        messages: [{ role: 'user', content: 'Task: Complete project, in-progress, urgent development, priority 4' }],
        model: 'gpt-4-turbo',
        response_model: {
          schema: TaskSchema,
          name: 'Task',
        },
      });

      expect(result).toEqual(expectedResult);
    });

    it('should handle schemas with descriptions', async () => {
      const PersonSchema = z.object({
        firstName: z.string().describe('The person\'s first name'),
        lastName: z.string().describe('The person\'s last name'),
        email: z.string().email().describe('Valid email address'),
        age: z.number().min(0).max(150).describe('Age in years'),
      });

      const expectedResult = {
        firstName: 'Jane',
        lastName: 'Smith',
        email: 'jane.smith@example.com',
        age: 25,
      };

      mockInstructorInstance.chat.completions.create.mockResolvedValue(expectedResult);

      const client = createInstructorClient({
        provider: 'openai',
        apiKey: 'test-key',
      });

      const createMethod = client.chat.completions.create as any;
      const result = await createMethod({
        messages: [{ role: 'user', content: 'Extract person: Jane Smith, jane.smith@example.com, 25 years old' }],
        model: 'gpt-4-turbo',
        response_model: {
          schema: PersonSchema,
          name: 'Person',
        },
      });

      expect(result).toEqual(expectedResult);
      
      // Verify that the schema with descriptions was passed correctly
      const callArgs = mockInstructorInstance.chat.completions.create.mock.calls[0][0];
      expect(callArgs.response_model.schema).toBe(PersonSchema);
    });

    it('should handle retry parameters', async () => {
      const SimpleSchema = z.object({
        value: z.string(),
      });

      const expectedResult = { value: 'test' };
      mockInstructorInstance.chat.completions.create.mockResolvedValue(expectedResult);

      const client = createInstructorClient({
        provider: 'openai',
        apiKey: 'test-key',
      });

      const createMethod = client.chat.completions.create as any;
      const result = await createMethod({
        messages: [{ role: 'user', content: 'Extract: test value' }],
        model: 'gpt-4-turbo',
        response_model: {
          schema: SimpleSchema,
          name: 'Simple',
        },
        max_retries: 3,
      });

      expect(result).toEqual(expectedResult);
      
      // Verify max_retries was passed through
      const callArgs = mockInstructorInstance.chat.completions.create.mock.calls[0][0];
      expect(callArgs.max_retries).toBe(3);
    });

    it('should handle different providers', async () => {
      // Test Claude provider
      const claudeClient = createInstructorClient({
        provider: 'claude',
        apiKey: 'claude-key',
      });

      expect(claudeClient).toBeDefined();
      expect(claudeClient.chat.completions.create).toBeDefined();

      // Test Gemini provider
      const geminiClient = createInstructorClient({
        provider: 'gemini',
        apiKey: 'gemini-key',
      });

      expect(geminiClient).toBeDefined();
      expect(geminiClient.chat.completions.create).toBeDefined();
    });
  });

  describe('Schema Validation Concepts', () => {
    it('should demonstrate that instructor-js handles Zod validation automatically', () => {
      // This test demonstrates the concept that instructor-js:
      // 1. Takes Zod schemas as input
      // 2. Converts them to appropriate LLM formats (JSON Schema, tool definitions)
      // 3. Handles validation and retries automatically
      // 4. Returns properly typed results

      const ComplexSchema = z.object({
        user: z.object({
          name: z.string().min(1),
          email: z.string().email(),
          preferences: z.object({
            theme: z.enum(['light', 'dark']),
            notifications: z.boolean(),
          }),
        }),
        metadata: z.object({
          createdAt: z.string().datetime(),
          tags: z.array(z.string()),
          score: z.number().min(0).max(100),
        }),
      });

      // The key insight is that instructor-js accepts the Zod schema directly
      // and handles all the conversion and validation logic internally
      expect(ComplexSchema).toBeDefined();
      expect(ComplexSchema._def.typeName).toBe('ZodObject');
      
      // This demonstrates that our integration preserves the Zod schema structure
      // that instructor-js needs for automatic processing
      const schemaKeys = Object.keys(ComplexSchema.shape);
      expect(schemaKeys).toContain('user');
      expect(schemaKeys).toContain('metadata');
    });
  });
});
